# tmux-rs

An in-progress rust port of tmux. This project should be considered pre-alpha quality and may not necessarily be in a building state.

I don't think or want this project to displace tmux. I love using tmux.
Tmux will also continue development while I'm working on this port,
so the structure of the rust code must match that of the C project.
I tried out using [zellij](https://zellij.dev/) once and gave up when the compilation time was something like 40 minutes on my machine.
For me, this refactor is kinda like gardening (I don't garden, but if I did I'd imagine that's what it's like).
Every minute I spend on this is a minute I don't spend mindlessly playing some video game, so I take it as a net win.

I started this endeavour as a way of getting first hand experience with using C2Rust.
It's simultaneously a great and a terrible tool. I was amazed when I used it that it
was able to produce rust code which compiled to a binary which was effectively equivalent to the original C binary.
Unfortunately, the resulting rust code ... leaves a lot to be desired.
My initial approach was starting with the mess generated by C2Rust and slowly de-duplicating
the section generated from the headers and then manually re-writing file by file.

The problem with this approach is the C2Rust duplicates the definitions from C `.h` header files.
This means every ~200 line C file results in a >1000 line rust file.
Furthermore, the Rust code generated is unsafe (this is okay), and unreadable (unacceptable).
The generated code doesn't retain the original intent of the C code, though it may be equivalent.
Think using constants like `42` instead of `b'*'` when the original C code used `'*'`.
The code may be equivalent, but it renders the resulting Rust code useless without the original C source.
That's not the goal of a port. You want to be able to through away the original code after the port and not have lost any information.

Eventually, I got to a point where I had so much in progress code in a non-building state that I gave up
and had to rethink this approach to porting. I've since started over many times.
My current approach is creating many "micro-crates" each of which correspond to each `.c` translational unit.
For now, this approach requires some manual editing of generated Makefiles. This isn't ideal.
If my understanding of autotools was better, I'd try to seamlessly integrate the building of the rust
crates into the original project structure. For now I have a `build.sh` script in the root which
calls make and cargo.

I think the better approach is to mimic the C functions abi with rust extern ffi definitions.
Then successively convert the ffi bindings into implementations. Using a single crate with modules
so it's easy to handle circular deps. I guess the problem is build system. It's difficult to have
a single file partially implemented. each can be all or nothing


One problem is translation has to occur at the file level. Requiring porting to happen in such
a way that there is a large amount of work in progress. Consider instead if it's possible to
break it up at the function level for larger files. It would depend on the file and function,
but I remove the function from the C file, but have it in the rust code so that there is no linking
issue.

# Steps

1. Pick a C file to port
  a. Pick a symbol (function or variable) to port
  b. cut the definition from the C file
  c. paste into the rust file and translate from C to Rust
2. Once all functions in a C file are ported
  a. Modify Makefile.am to remove the C file from sources list
  b. run `sh autogen.sh && ./configure` to regenerate Makefile


## Tips

- Use clang-format or other to reformat the C code quickly

- Picking a C file: Start with root files in the project. (files with no or few dependencies on the rest of the project)
- You cannot link multiple static rust libraries (.a) into a single compilation artifact. There will be duplicate symbols.
- Seems a common source of bugs is stubbing something and intending to come back to it later, but not. Avoid this.
- SEGFAULTS, crashes, panics are much easier to debug then infinite loops and other types of bugs because you get a stack trace

## Debugging Tips
- reduce problem to single function. set a breakpoint on that function. walk through it in old and new version and notice differences
- if crashing on user action, start, get pid of second process; attach gdb on second process without follow child mode; continue; trigger action, hopefully gdb will be at the point where the crash occurred

# C Stuff

- integer promotion rules
- rust literal value inference
- prototypes
- variadics


# Progress

Current status:

reverted environ from build

implement fatal and fatalx which accept static rust string

```
0x606000001160 rb_entry { rbe_left: 0x0, rbe_right: 0x606000001820, rbe_parent: 0x6060000009e0, rbe_color: RB_BLACK }
0x0
AddressSanitizer:DEADLYSIGNAL
=================================================================
==80540==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000030 (pc 0x55741df91844 bp 0x7ffd34fc7cd0 sp 0x7ffd34fc7890 T0)
==80540==The signal is caused by a READ memory access.
==80540==Hint: address points to the zero page.
    #0 0x55741df91844 in compat_rs::tree::rb_color::h5bf1ff1355d9e6c7 /home/collin/Git/tmux/tmux-3.5a/compat_rs/src/tree.rs:123:14
    #1 0x55741df8b1e3 in compat_rs::tree::rb_remove_color::h69ea0937ab2c4b6f /home/collin/Git/tmux/tmux-3.5a/compat_rs/src/tree.rs:317:20
    #2 0x55741df941bf in compat_rs::tree::rb_remove::h2dc7ad830c5919d2 /home/collin/Git/tmux/tmux-3.5a/compat_rs/src/tree.rs:475:13
    #3 0x55741dfc1cf8 in tmux_rs::environ_::environ_free::_$u7b$$u7b$closure$u7d$$u7d$::hbb3f0349d4e4a987 /home/collin/Git/tmux/tmux-3.5a/tmux_rs/src/environ_.rs:32:13
    #4 0x55741df8811d in compat_rs::tree::rb_foreach_safe::hb20b2c7acc7dc97b /home/collin/Git/tmux/tmux-3.5a/compat_rs/src/tree.rs:598:19
    #5 0x55741dfbabcc in environ_free /home/collin/Git/tmux/tmux-3.5a/tmux_rs/src/environ_.rs:29:9
    #6 0x55741dcd7d30 in client_main /home/collin/Git/tmux/tmux-3.5a/client.c:341:2
    #7 0x55741ded0adb in main /home/collin/Git/tmux/tmux-3.5a/tmux.c:537:7
    #8 0x7f5e1e244249 in __libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16
    #9 0x7f5e1e244304 in __libc_start_main csu/../csu/libc-start.c:360:3
    #10 0x55741dc0b8e0 in _start (/home/collin/Git/tmux/tmux-3.5a/tmux+0x1098e0) (BuildId: 75e35fd9ba583f7712f4e9194bec4b2337c0dbf7)

AddressSanitizer can not provide additional info.
SUMMARY: AddressSanitizer: SEGV /home/collin/Git/tmux/tmux-3.5a/compat_rs/src/tree.rs:123:14 in compat_rs::tree::rb_color::h5bf1ff1355d9e6c7
==80540==ABORTING
```

need to be able to get some more useful information when.
more then just server exited unexpectedly.
- figure out debug logs
- figure out abort / panic logs
- get a stacktrace on segfault

# NEXT (ensure only has one item)
I suspect that linking is shadowing some broken rust implementations,
and maybe when compiling with rust the rust implementation is prefered
improve imsg and imsg buffer implemnentation


# TODO
- review cmd_rotate_window.rs cmd_rotate_window_exec tailq_foreach calls
- memory sanitizer
- dump backtrace on abort
  - gdb break
    - client_main
    - client_connect
    - server_start
    - proc_fork_and_daemon
    - proc loop server loop
  - research extern c-unwind vs c: <https://rust-lang.github.io/rfcs/2945-c-unwind-abi.html>
    - should I use c-unwind for all abi's?
- better rust format string style logging functions
- tailq and rbtree
  - recheck all tailq, and rbtree structs for multiple links.
  - derive macro for rbtree and tailq
    - tailq support new generic type discriminant
  - fully complete library / crate implementation with documentation
- use bitflags instead of manually 

# Thoughts
- better rust-analyzer integration with C code

# Interesting Patterns

- goto labeled block translation
- bitflags

# TODO After 100% Rust
- miri
- coverage
- convert to references instead of pointers
  - requirements to convert pointer to reference <https://doc.rust-lang.org/core/ptr/index.html#pointer-to-reference-conversion>
    - interleaving accesses between refs and ptrs seems to be not allowed
      - <https://doc.rust-lang.org/nightly/core/ptr/index.html#safety>
      - <https://github.com/rust-lang/unsafe-code-guidelines/issues/463>
    - when converting from ptr to ref need to ensure types are initialized and valid when passed into a function
    - read or writes through a ptr will invalidate a reference
    - also need to ensure no pointers are created and stored from the references
    - NonNull use as_uninit_mut
- get rid of paste crate, won't need to join symbols any more for C code
- figure out why building rust binary doesn't work

- [ ]  493 server-fn
- [ ]  510 tty-features
- [ ]  556 menu
- [ ]  559 window-buffer
- [ ]  691 layout-set
- [ ]  692 key-bindings
- [ ]  740 screen
- [ ]  759 session
- [ ]  794 input-keys
- [ ]  818 popup
- [ ]  868 screen-redraw

- [ ] 1120 layout
- [ ] 1204 options
- [ ] 1243 format-draw
- [ ] 1266 mode-tree
- [ ] 1348 window-tree
- [ ] 1370 options-table
- [ ] 1512 window-customize
- [ ] 1535 grid
- [ ] 1591 tty-keys
- [ ] 2035 status
- [ ] 2347 screen-write
- [ ] 3025 input
- [ ] 3186 tty
- [ ] 3392 server-client
- [ ] 5294 format
- [ ] 5786 window-copy
- [ ] broken, partially ported files
  - [ ]  281 environ (environ_free is broken, everything else works)
  - [ ]  323 notify (notify_add)
  - [ ] 557 server (server_loop is broken)
  - [ ]  899 cmd-queue (some tailq functions used port isn't working) (TODO move into broken)
- [X] 874 cmd
  - [ ]  370 cmd-new-session (doesn't work, crashes on startup)
  =====
  - [ ]  159 cmd-parse.y (partially translated), need to figure out an approach to get rid of yacc/bison
  =====
- [X]  924 tty-term
- [X]  477 key-string
- [X]  467 resize
- [X]  429 grid-reader
- [X]  418 window-client
- [X]  370 layout-custom
- [X]  269 tty-acs
- [X]  235 grid-view
- [X]  286 window-clock
- [X] window
- [X] 325 alert
- [X] 1097 arguments
- [X]  108 attributes
- [X]  277 cfg
- [X]  809 client
- [X] 1117 colour
- [X]      compat
- [X]  262 control-notify
- [X]  435 job
- [X]      log
- [X]  172 names
- [X] 120 regsub
- [X]  383 style
- [X]  538 tmux.c
- [X] tmux.h
- [X] tmux-protocol.h
- [X] xmalloc
- [X]  859 file
- [X] 1117 control
- [X] 388 proc
- [X] 100 utf8-combined
- [X] 822 utf8
- [X] 342 paste
- [X]  239 hyperlinks
- [X]  497 spawn
- [X]  186 server-acl
  - [X] 1314 cmd-find
  - [X]  215 cmd-resize-pane
  - [X]  290 cmd-run-shell
  - [X]  264 cmd-wait-for
  - [X]  260 cmd-show-options
  - [X]  242 cmd-select-pane
  - [X]  335 cmd-refresh-client
  - [X]  239 cmd-set-option
  - [X]  237 cmd-send-keys
  - [X]  230 cmd-pipe-pane
  - [X]  199 cmd-split-window
  - [X]  372 cmd-list-keys
  - [X]  312 cmd-display-panes
  - [X]      cmd-kill-server
  - [X]   62 cmd-rename-window
  - [X]   67 cmd-kill-pane
  - [X]   71 cmd-kill-session
  - [X]   79 cmd-lock-server
  - [X]   81 cmd-list-buffers
  - [X]   81 cmd-rename-session
  - [X]   90 cmd-list-sessions
  - [X]   94 cmd-swap-window
  - [X]   95 cmd-respawn-window
  - [X]   98 cmd-copy-mode
  - [X]   98 cmd-respawn-pane
  - [X]  102 cmd-list-clients
  - [X]  104 cmd-unbind-key
  - [X]  107 cmd-bind-key
  - [X]  107 cmd-show-messages
  - [X]  108 cmd-show-prompt-history
  - [X]  109 cmd-detach-client
  - [X]  110 cmd-kill-window
  - [X]  113 cmd-load-buffer
  - [X]  113 cmd-paste-buffer
  - [X]  115 cmd-resize-window
  - [X]  115 cmd-rotate-window
  - [X]  116 cmd-find-window
  - [X]  117 cmd-choose-tree
  - [X]  119 cmd-set-environment
  - [X]  120 cmd-save-buffer
  - [X]  122 cmd-move-window
  - [X]  130 cmd-list-windows
  - [X]  137 cmd-set-buffer
  - [X]  142 cmd-switch-client
  - [X]  143 cmd-break-pane
  - [X]  143 cmd-show-environment
  - [X]  147 cmd-server-access
  - [X]  148 cmd-list-panes
  - [X]  148 cmd-swap-pane
  - [X]  149 cmd-select-layout
  - [X]  150 cmd-select-wind
  - [X]  159 cmd-display-message
  - [X]  159 cmd-new-window
  - [X]  163 cmd-confirm-before
  - [X]  175 cmd-attach-session
  - [X]  180 cmd-join-pane
  - [X]  190 cmd-if-shell
  - [X]  242 cmd-command-prompt
  - [X]  253 cmd-capture-pane
  - [X]  502 cmd-display-menu

# Ideas

- emulate rust scoped enums with modules, structs and constants


# Notes

## Compat

tmux is a *bsd project.
I'm not sure which bsd exactly, but it's clear from reading the source code there's many libc functions
used which don't exist on linux, and are provided by bsd. The tmux project makes use of code in the compat
directory and autotools to shim these functions on OS's which they aren't provided. The first area to port
is this. Many linux distro's provide some of these functions already implemented through a library called
libbsd. I made a libbsd-sys library that provides auto-generated rust bindings to this C library. The surface
area of these functions is quite small and could easily be reimplemented later to remove this dependency.

## queue.h and tree.h

The tmux project makes extensive use of macros in the `compat/queue.h` and `compat/tree.h` headers which
implement an intrusive linked list and intrusive red black tree. For the most part, I've been able
to mirror the implementations at the source level using Rust generics. This is a key area to get right.
The auto-generated expanded C macros generated a mess from this code. This code needs to be hand crafted
properly to make use of rust generics which is abi compatible with the original C code. Maybe in the future
it would make sense to instead make use of a crate which provides the same functionality such as [intrusive_collections](https://docs.rs/intrusive-collections/latest/intrusive_collections/).

## C pointer field access operator `->`

Once annoyance of porting C code which makes heavy use of pointers is having to convert uses of the `->` operator.
Rust has no such operator and pointers don't implement deref, so they must be translated to something like `(*w).field`.

For a bit, I thought I could implement by own smart pointer type which wrapped a `*mut T` or `NonNull` and also
implemented DerefMut. Unfortunately doing this requires that you can create a `&mut T` which would likely invoke
undefined behaviour in this context.

## BUGS

- keybinding for vertical split prefix - doesn't seem to perform the correct action
  - related to current translation of arguments.c
- keybinding for new window prefix-c doesn't seem to work
  - started occurring after translating client.c
- TODO, noticed I flipped tranlation order of fields of args_parse struct. need to double check that all translations which use the initialization is correct
- Attaching to an existing tmux session is broken.
  - running `tmux attach` immediately crashes when a session exists
  - when running tmux while an existing tmux instance is running causes it to hang, killing the pane causes it to properly attach (likely do to my tmux config)
- Anything entered in command prompt enter causes crash
- with my rebinding C-b C to new window in current directory causes issues. with it unbound, there's no problem.
- crashes when typing 'c' because of one of my bindings
- crashes on my binding prefix g

- sendmsg in client to server causes SIGPIPE to be handled and exit control loop


Due to use after shadowing in client_.rs client_connect xasprintf usage
found by using LSAN_OPTIONS=report_objects=1
leak on exit:
```
â¯ ./tmux
[exited]

=================================================================
==32510==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 28 byte(s) in 1 object(s) allocated from:
    #0 0x5596d8e5f64e in __interceptor_malloc (/home/collin/Git/tmux/tmux-3.5a/tmux+0x19964e) (BuildId: 960e62ee7f022a651d2c597decbeb02aba2b15cd)
    #1 0x7fbd5e1b0427 in __vasprintf_internal libio/./libio/vasprintf.c:71:30

SUMMARY: AddressSanitizer: 28 byte(s) leaked in 1 allocation(s).
```

```
// cs is null and causes segfault on tmux attach
    395  #[unsafe(no_mangle)]
    396  pub unsafe extern "C" fn control_write(c: *mut client, fmt: *const c_char, mut ap: ...) {
    397      let __func__ = c"control_write".as_ptr();
    398      unsafe {
    399          let cs = (*c).control_state;
    400
>   401          if tailq_empty(&raw mut (*cs).all_blocks) {
    402              control_vwrite(c, fmt, ap.as_va_list());
    403              return;
    404          }
```


```
   1684                  case EV_CLOSURE_EVENT: {                                        
   1685                          void (*evcb_callback)(evutil_socket_t, short, void *);
   1686                          short res;                                               
   1687                          EVUTIL_ASSERT(ev != NULL);                               
   1688                          evcb_callback = *ev->ev_callback;                        
   1689                          res = ev->ev_res;                                        
   1690                          EVBASE_RELEASE_LOCK(base, th_base_lock);                 
>  1691                          evcb_callback(ev->ev_fd, res, ev->ev_arg);  
```

## BUGS (found)

- Incorrect translation of do while
- Incorrect translation of != null check
- incorrect translation of self-referential struct (just used null to init because lazyness when translating)
- missing init for tailq in struct // the big one causing crash on init
- missing break at end of loop emulating goto in rb_remove: hangs on Ctrl-D
- missing field in struct translation
- incorrect field in struct. used struct instead of struct pointer
- flipped == args_type::ARGS_NONE instead of flipped != args_type::ARGS_NONE
- flipped != 0 instead of == 0 for coverting from !int_like_value in conditional
- incorrect translation of for loop with continue to while with continue and increment at end; increment isn't applied (cmd_find)
- incorrect translation of cmd_entry args_parse cb None, when should have been Some(cb): after translating cmd-display-menu immediately aborts on start
- typo in rb_right macro, expanded to access left field
- crashes when config file is completely commented out: missing early exit in cmdq_get_command, no return in function

- memcpy_(&raw mut tmp as *mut i8, in_, end); should have been: memcpy_(tmp, in_, end)
  -  because I switched to a pointer instead of buffer,but didn't change memcpy code
- typo fps, fsp, variable unused null , cmd-queue.c ( causing crash when C-b t for clock)
- missing C prototype :struct cmd_parse_commands * cmd_parse_do_buffer(const char *buf, size_t len, struct cmd_parse_input *pi, char **cause)
  - return address value truncated to int
- for loop never entered didn't init variable needed for side effect after for loop ended (arguments)
- incorrect for loop translation. used 1..count, but should have used while loop
- extra copy paste: duplicate value += 1; value +=1;
- flipped null check
- flipped : char		 acs[UCHAR_MAX + 1][2]; -> pub acs: [[c_char; c_uchar::MAX as usize + 1]; 2], should be [[c_char; 2]; c_uchar::MAX as usize + 1],

# References

- [tmux](https://github.com/tmux/tmux)
- [C2Rust](https://github.com/immunant/c2rust)
- [rust-bindgen](https://rust-lang.github.io/rust-bindgen/)
- [Compiling C to Safe Rust, Formalized](https://arxiv.org/abs/2412.15042)
- [Porting C to Rust for a Fast and Safe AV1 Media Decoder](https://www.memorysafety.org/blog/porting-c-to-rust-for-av1/)
- [Fish 4.0: The Fish Of Theseus](https://fishshell.com/blog/rustport/)
- [Immunant's C2Rust tmux](https://github.com/immunant/tmux-rs)
- [Improved C Variadics in Rust and C2Rust](https://immunant.com/blog/2019/09/variadics/)
